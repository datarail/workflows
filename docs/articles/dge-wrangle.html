<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wrangling DGE output of bcbio • workflows</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><meta property="og:title" content="Wrangling DGE output of bcbio">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">workflows</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">0.1</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    DGE
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/dge-wrangle.html">Wrangling bcbio output</a>
    </li>
    <li>
      <a href="../articles/dge-pca.html">Principal Component Analysis</a>
    </li>
  </ul>
</li>
<li>
  <a href="../reference/index.html">Helper Functions</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/datarail/workflows">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Wrangling DGE output of bcbio</h1>
                        <h4 class="author">Artem Sokolov</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/datarail/workflows/blob/master/vignettes/dge-wrangle.Rmd"><code>vignettes/dge-wrangle.Rmd</code></a></small>
      <div class="hidden name"><code>dge-wrangle.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>This vignette demonstrates how to wrangle the output <code>bcbio</code> after it was used to align FASTQ files from a Digital Gene Expression (DGE) experiment. After running <code>bcbio</code>, you should see the following files in the output directory:</p>
<ul>
<li><code>..._DGE.mtx</code></li>
<li><code>..._DGE.mtx.rownames</code></li>
<li><code>..._DGE.mtx.colnames</code></li>
<li><code>barcodes_trugrade_384_set1.dat</code></li>
</ul>
<p>where <code>...</code> would contain your project / sample name. If you followed the installation instructions on the main page, you can download an example dataset to follow along in this vignette.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">workflows::<span class="kw"><a href="../reference/getData.html">getData</a></span>( <span class="st">"dge-wrangle"</span> )</code></pre></div>
<p>We will take advantage of two libraries: tidyverse and <a href="https://github.com/stephenturner/annotables">annotables</a>. The former allows us to manipulate data frames in a variety of ways, while the second package contains pre-computed mapping between Ensembl IDs and HUGO gene names. Both packages should be pre-installed, if you followed the installation instructions on the main page. We load the packages using</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>( annotables )
<span class="kw">library</span>( tidyverse )</code></pre></div>
</div>
<div id="loading-raw-files" class="section level2">
<h2 class="hasAnchor">
<a href="#loading-raw-files" class="anchor"></a>Loading raw files</h2>
<p><strong>A. <code>N702_DGE.mtx</code> contains counts in a “long” matrix format (each row of the data specifies a row - column - value triplet).</strong> Doing <code>head N702_DGE.mtx</code> on the command line reveals that the file is in a space-delimited format with lines comments on lines 1-2, general statistics of the matrix on line 3 (58302 rows, 384 columns, and 4406901 entries), and the data itself beginning on line 4. In R, we load this file as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">X &lt;-<span class="st"> </span><span class="kw">read_delim</span>( <span class="st">"data/dge-wrangle/N702_DGE.mtx"</span>, <span class="st">" "</span>, <span class="dt">comment=</span><span class="st">"%"</span> )</code></pre></div>
<p>By telling the function that lines beginning with <code>%</code> are comments, we ensure that it correctly skips the first two lines in the file. The function then treats statistics on the third line as column names, resulting in the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(X)</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   `58302` `384` `4406898`
##     &lt;int&gt; &lt;int&gt;     &lt;int&gt;
## 1       1     1         2
## 2       1     2        14
## 3       1     3         4
## 4       1     4        17
## 5       1     5        17
## 6       1     6        17</code></pre>
<p>Let’s rename them to something more meaningful. The function <code>select</code> is normally used to select a subset of columns in data frame, allowing for renaming of individual columns in the process. Here, we can use it for the latter effect by selecting all three columns and giving them new names:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">X &lt;-<span class="st"> </span>X %&gt;%<span class="st"> </span><span class="kw">select</span>( <span class="dt">rowIndex =</span> <span class="dv">1</span>, <span class="dt">colIndex =</span> <span class="dv">2</span>, <span class="dt">Value =</span> <span class="dv">3</span> )
<span class="kw">head</span>(X)</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   rowIndex colIndex Value
##      &lt;int&gt;    &lt;int&gt; &lt;int&gt;
## 1        1        1     2
## 2        1        2    14
## 3        1        3     4
## 4        1        4    17
## 5        1        5    17
## 6        1        6    17</code></pre>
<p>We now know that the final counts matrix should be of dimensions 58,302 by 384, where each row corresponds to a gene and each column corresponds to a well. Before we reshape our matrix, we should map row indices to gene names and column indices to well IDs. This is what the other files are for.</p>
<p><strong>B. <code>N702_DGE.mtx.rownames</code> contains gene names (as Ensembl IDs) for each row in the counts matrix.</strong> Doing <code>head N702_DGE.mtx.rownames</code> on the command line shows that the file simply contains one Emsembl ID per line. We can therefore treat this is a one-column comma-delimited file (or tab-delimited; since there’s only one column, the delimiter doesn’t matter):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Load our one-column comma-delimited file, giving an explicit name to the only column
rn &lt;-<span class="st"> </span><span class="kw">read_csv</span>( <span class="st">"data/dge-wrangle/N702_DGE.mtx.rownames"</span>, <span class="dt">col_names =</span> <span class="st">"ENSEMBL"</span> )</code></pre></div>
<p>While Ensembl IDs provide a unique way to identify individual genes, most biologists interpret data based on HUGO IDs instead. The package <code>annotables</code> that we installed earlier contains precomputed mapping between Ensembl and HUGO IDs for the latest human genome assembly. Let’s look at the first few rows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>( annotables::grch38 )</code></pre></div>
<pre><code>## # A tibble: 6 x 9
##   ensgene  entrez symbol chr    start    end strand biotype description   
##   &lt;chr&gt;     &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;  &lt;int&gt;  &lt;int&gt;  &lt;int&gt; &lt;chr&gt;   &lt;chr&gt;         
## 1 ENSG000…   7105 TSPAN6 X     1.01e8 1.01e8     -1 protei… tetraspanin 6…
## 2 ENSG000…  64102 TNMD   X     1.01e8 1.01e8      1 protei… tenomodulin […
## 3 ENSG000…   8813 DPM1   20    5.09e7 5.10e7     -1 protei… dolichyl-phos…
## 4 ENSG000…  57147 SCYL3  1     1.70e8 1.70e8     -1 protei… SCY1 like pse…
## 5 ENSG000…  55732 C1orf… 1     1.70e8 1.70e8      1 protei… chromosome 1 …
## 6 ENSG000…   2268 FGR    1     2.76e7 2.76e7     -1 protei… FGR proto-onc…</code></pre>
<p>We observe that the first and third columns contain the mapping we are looking for. Using our previous experience with <code>select</code>, we isolate both columns and give them meaningful names:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">E2H &lt;-<span class="st"> </span>annotables::grch38 %&gt;%<span class="st"> </span><span class="kw">select</span>( <span class="dt">ENSEMBL =</span> ensgene, <span class="dt">HUGO =</span> symbol ) %&gt;%
<span class="st">    </span><span class="kw">filter</span>( !<span class="kw">duplicated</span>( HUGO ) )
<span class="kw">head</span>( E2H )</code></pre></div>
<pre><code>## # A tibble: 6 x 2
##   ENSEMBL         HUGO    
##   &lt;chr&gt;           &lt;chr&gt;   
## 1 ENSG00000000003 TSPAN6  
## 2 ENSG00000000005 TNMD    
## 3 ENSG00000000419 DPM1    
## 4 ENSG00000000457 SCYL3   
## 5 ENSG00000000460 C1orf112
## 6 ENSG00000000938 FGR</code></pre>
<p>The last <code>filter</code> step removes duplicate <code>HUGO</code> IDs. Most of those map to small nucleoar RNA, so minimal biological insight is lost.</p>
<p>Before merging the mapping with the IDs we loaded from <code>N702_DGE.mtx.rownames</code>, we have to make a decision: do we want to keep around rows of the matrix for which there was no HUGO ID? For the purposes of this vignette, the answer is “no”, we only want to keep rows that can be mapped to HUGO to assist with biological interpretation. We will therefore merge the mapping with <code>N702_DGE.mtx.rownames</code> using <code>inner_join()</code>, which is a function that takes two data frames and keeps only those rows that occur in both of them. If the answer in your own experiment is “yes”, we want to keep all Ensembl IDs from <code>N702_DGE.mtx.rownames</code>, not just those that map to HUGO, then you should replace <code>inner_join</code> with <code>left_join</code>, which also merges two data frames, but it keeps all the rows in its left (first) argument and assigns <code>NA</code> to those rows that are missing in its right argument. (As you can probably guess, there’s also <code>right_join</code>, which does the opposite, as well as <code>full_join</code>, which keeps all rows from both data frames and cross-assigns <code>NA</code> as necessary).</p>
<p>Regardless of whether you’re keeping all Ensembl IDs or just those that map to HUGO, we need to ensure that the gene names can still be associated with the row index in the final matrix. Before we do any merging, we need to add a column that maintains the association between <code>N702_DGE.mtx</code> and <code>N702_DGE.mtx.rownames</code>. Recall that we renamed our first column of <code>X</code> to <code>rowIndex</code>. We must use the same name here, to ensure that everything can be correctly joined later:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rn &lt;-<span class="st"> </span>rn %&gt;%<span class="st"> </span><span class="kw">mutate</span>( <span class="dt">rowIndex =</span> <span class="dv">1</span>:<span class="dv">58302</span> )
<span class="kw">head</span>(rn)</code></pre></div>
<pre><code>## # A tibble: 6 x 2
##   ENSEMBL         rowIndex
##   &lt;chr&gt;              &lt;int&gt;
## 1 ENSG00000000003        1
## 2 ENSG00000000005        2
## 3 ENSG00000000419        3
## 4 ENSG00000000457        4
## 5 ENSG00000000460        5
## 6 ENSG00000000938        6</code></pre>
<p>Note that we explicitly specify the number of genes that are captured by matrix <code>X</code>, instead of dynamically computing it using <code>nrow(rn)</code>. This provides a positive control that the number of rows in <code>rn</code> matches the number of genes captured by <code>X</code>. If <code>rn</code> did not have 58,302 rows, then the above command would produce an error.</p>
<p>Now that we explicitly captured the association between Ensembl IDs and row indices, all that remains to do with map Ensembl IDs to HUGO, using our mapping from above:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rn &lt;-<span class="st"> </span><span class="kw">inner_join</span>( rn, E2H )</code></pre></div>
<pre><code>## Joining, by = "ENSEMBL"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(rn)</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   ENSEMBL         rowIndex HUGO    
##   &lt;chr&gt;              &lt;int&gt; &lt;chr&gt;   
## 1 ENSG00000000003        1 TSPAN6  
## 2 ENSG00000000005        2 TNMD    
## 3 ENSG00000000419        3 DPM1    
## 4 ENSG00000000457        4 SCYL3   
## 5 ENSG00000000460        5 C1orf112
## 6 ENSG00000000938        6 FGR</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(rn)</code></pre></div>
<pre><code>## [1] 56468     3</code></pre>
<p><strong>C. <code>N702_DGE.mtx.colnames</code> contains well barcords for each column in the counts matrix.</strong> Doing <code>head N702_DGE.mtx.colnames</code> on the command line, we observe that it’s once again a file with a single entry per-line. As before, let’s treat it as a single-column comma-delimited file, which we load using <code>read_csv</code> and append an additional column to create an association between column names and column indices:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cn &lt;-<span class="st"> </span><span class="kw">read_csv</span>( <span class="st">"data/dge-wrangle/N702_DGE.mtx.colnames"</span>, <span class="dt">col_names =</span> <span class="st">"Barcode"</span> ) %&gt;%
<span class="st">    </span><span class="kw">mutate</span>( <span class="dt">colIndex =</span> <span class="dv">1</span>:<span class="dv">384</span> )</code></pre></div>
<p>As before, we explicitly provide a vector of indices that is of length 384, to ensure that it’s compatible with what we expected to load from <code>N702_DGE.mtx.colnames</code>. Let’s look at the first few lines to ensure that everything looks OK.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(cn)</code></pre></div>
<pre><code>## # A tibble: 6 x 2
##   Barcode colIndex
##   &lt;chr&gt;      &lt;int&gt;
## 1 AAAACT         1
## 2 AAAATC         2
## 3 AAACAT         3
## 4 AAACTA         4
## 5 AAAGTT         5
## 6 AAATAC         6</code></pre>
<p>Just like the case with gene names where we wanted to map Ensembl IDs to HUGO, we also want to map barcodes to well names. This information is contained in the last file: <code>barcodes_trugrade_384_set1.dat</code>. Checking the file content on the command line using <code>head</code>, we note that it’s a three-column tab-delimited file. Let’s load it and give each column a meaningful name:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">B2W &lt;-<span class="st"> </span><span class="kw">read_tsv</span>( <span class="st">"data/dge-wrangle/barcodes_trugrade_384_set1.dat"</span>,
                <span class="dt">col_names =</span> <span class="kw">c</span>(<span class="st">"SetID"</span>, <span class="st">"Well"</span>, <span class="st">"Barcode"</span>) )</code></pre></div>
<p>Note that once again, we need to ensure consistency in column names because <code>inner_join()</code> will use them to identify matching columns between multiple data frames. In this particular case, <code>Barcode</code> is present in both <code>cn</code> and <code>B2W</code>. We are now ready to merge the two:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>( B2W )</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   SetID  Well  Barcode
##   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;  
## 1 T384s1 A1    AAAACT 
## 2 T384s1 A2    AAAATC 
## 3 T384s1 A3    AAAGTT 
## 4 T384s1 A4    AAATAC 
## 5 T384s1 A5    AAATTG 
## 6 T384s1 A6    AACAAT</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cn &lt;-<span class="st"> </span><span class="kw">inner_join</span>( cn, B2W )</code></pre></div>
<pre><code>## Joining, by = "Barcode"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>( cn )</code></pre></div>
<pre><code>## # A tibble: 6 x 4
##   Barcode colIndex SetID  Well 
##   &lt;chr&gt;      &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;
## 1 AAAACT         1 T384s1 A1   
## 2 AAAATC         2 T384s1 A2   
## 3 AAACAT         3 T384s1 B1   
## 4 AAACTA         4 T384s1 B2   
## 5 AAAGTT         5 T384s1 A3   
## 6 AAATAC         6 T384s1 A4</code></pre>
</div>
<div id="merging-everything" class="section level2">
<h2 class="hasAnchor">
<a href="#merging-everything" class="anchor"></a>Merging everything</h2>
<p>Now that we have the counts data loaded in <code>X</code>, gene names with the corresponding HUGO IDs in <code>rn</code>, and well barcodes with the corresponding well names in <code>cn</code>, we can merge everything into a single data frame by repeated application of <code>inner_join</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">XX &lt;-<span class="st"> </span><span class="kw">inner_join</span>( X, rn ) %&gt;%<span class="st"> </span><span class="kw">inner_join</span>( cn )</code></pre></div>
<pre><code>## Joining, by = "rowIndex"</code></pre>
<pre><code>## Joining, by = "colIndex"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(XX)</code></pre></div>
<pre><code>## # A tibble: 6 x 8
##   rowIndex colIndex Value ENSEMBL         HUGO   Barcode SetID  Well 
##      &lt;int&gt;    &lt;int&gt; &lt;int&gt; &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;
## 1        1        1     2 ENSG00000000003 TSPAN6 AAAACT  T384s1 A1   
## 2        1        2    14 ENSG00000000003 TSPAN6 AAAATC  T384s1 A2   
## 3        1        3     4 ENSG00000000003 TSPAN6 AAACAT  T384s1 B1   
## 4        1        4    17 ENSG00000000003 TSPAN6 AAACTA  T384s1 B2   
## 5        1        5    17 ENSG00000000003 TSPAN6 AAAGTT  T384s1 A3   
## 6        1        6    17 ENSG00000000003 TSPAN6 AAATAC  T384s1 A4</code></pre>
<p>In the resulting matrix, we only care about gene names in HUGO, well names and the number of counts that were detected for that gene in that well. As before, we use <code>select</code> to reduce the matrix to the columns of interest. (In this case, no renaming is necessary.)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">XX &lt;-<span class="st"> </span>XX %&gt;%<span class="st"> </span><span class="kw">select</span>( HUGO, Well, Value )
<span class="kw">head</span>(XX)</code></pre></div>
<pre><code>## # A tibble: 6 x 3
##   HUGO   Well  Value
##   &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;
## 1 TSPAN6 A1        2
## 2 TSPAN6 A2       14
## 3 TSPAN6 B1        4
## 4 TSPAN6 B2       17
## 5 TSPAN6 A3       17
## 6 TSPAN6 A4       17</code></pre>
<p>Lastly, we convert the matrix from “long” format to “wide” format, by putting each well into its own column:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">XX &lt;-<span class="st"> </span><span class="kw">spread</span>( XX, Well, Value, <span class="dt">fill=</span>0L )
<span class="kw">head</span>(XX)</code></pre></div>
<pre><code>## # A tibble: 6 x 385
##   HUGO      A1   A10   A11   A12   A13   A14   A15   A16   A17   A18   A19
##   &lt;chr&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1 A1BG       2     4     6     6     3     6     1     3     3     6     3
## 2 A1CF       0     1     0     0     1     0     0     0     0     0     0
## 3 A2M        0     1     0     3     0     2     1     2     0     1     0
## 4 A2ML1      0     0     0     1     1     1     0     1     0     0     0
## 5 A4GALT     0     2     1     1     1     0     2     2     1     0     2
## 6 A4GNT      0     0     0     0     0     0     0     0     0     0     0
## # ... with 373 more variables: A2 &lt;int&gt;, A20 &lt;int&gt;, A21 &lt;int&gt;, A22 &lt;int&gt;,
## #   A23 &lt;int&gt;, A24 &lt;int&gt;, A3 &lt;int&gt;, A4 &lt;int&gt;, A5 &lt;int&gt;, A6 &lt;int&gt;,
## #   A7 &lt;int&gt;, A8 &lt;int&gt;, A9 &lt;int&gt;, B1 &lt;int&gt;, B10 &lt;int&gt;, B11 &lt;int&gt;,
## #   B12 &lt;int&gt;, B13 &lt;int&gt;, B14 &lt;int&gt;, B15 &lt;int&gt;, B16 &lt;int&gt;, B17 &lt;int&gt;,
## #   B18 &lt;int&gt;, B19 &lt;int&gt;, B2 &lt;int&gt;, B20 &lt;int&gt;, B21 &lt;int&gt;, B22 &lt;int&gt;,
## #   B23 &lt;int&gt;, B24 &lt;int&gt;, B3 &lt;int&gt;, B4 &lt;int&gt;, B5 &lt;int&gt;, B6 &lt;int&gt;,
## #   B7 &lt;int&gt;, B8 &lt;int&gt;, B9 &lt;int&gt;, C1 &lt;int&gt;, C10 &lt;int&gt;, C11 &lt;int&gt;,
## #   C12 &lt;int&gt;, C13 &lt;int&gt;, C14 &lt;int&gt;, C15 &lt;int&gt;, C16 &lt;int&gt;, C17 &lt;int&gt;,
## #   C18 &lt;int&gt;, C19 &lt;int&gt;, C2 &lt;int&gt;, C20 &lt;int&gt;, C21 &lt;int&gt;, C22 &lt;int&gt;,
## #   C23 &lt;int&gt;, C24 &lt;int&gt;, C3 &lt;int&gt;, C4 &lt;int&gt;, C5 &lt;int&gt;, C6 &lt;int&gt;,
## #   C7 &lt;int&gt;, C8 &lt;int&gt;, C9 &lt;int&gt;, D1 &lt;int&gt;, D10 &lt;int&gt;, D11 &lt;int&gt;,
## #   D12 &lt;int&gt;, D13 &lt;int&gt;, D14 &lt;int&gt;, D15 &lt;int&gt;, D16 &lt;int&gt;, D17 &lt;int&gt;,
## #   D18 &lt;int&gt;, D19 &lt;int&gt;, D2 &lt;int&gt;, D20 &lt;int&gt;, D21 &lt;int&gt;, D22 &lt;int&gt;,
## #   D23 &lt;int&gt;, D24 &lt;int&gt;, D3 &lt;int&gt;, D4 &lt;int&gt;, D5 &lt;int&gt;, D6 &lt;int&gt;,
## #   D7 &lt;int&gt;, D8 &lt;int&gt;, D9 &lt;int&gt;, E1 &lt;int&gt;, E10 &lt;int&gt;, E11 &lt;int&gt;,
## #   E12 &lt;int&gt;, E13 &lt;int&gt;, E14 &lt;int&gt;, E15 &lt;int&gt;, E16 &lt;int&gt;, E17 &lt;int&gt;,
## #   E18 &lt;int&gt;, E19 &lt;int&gt;, E2 &lt;int&gt;, E20 &lt;int&gt;, E21 &lt;int&gt;, E22 &lt;int&gt;, …</code></pre>
<p>By default, <code>spread()</code> will fill missing values with NA. However, in the case of a DGE experiment, a missing value implies “no counts detected” and should really be a zero value. This is what the <code>fill</code> argument is for. (<code>0L</code> is a way to tell <code>R</code> that the value should be explicitly treated as an integer, not a real.)</p>
<p>The result can be stored to a file using <code>write_tsv</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">write_tsv</span>( XX, <span class="st">"data/dge-wrangle/N702_wrangled.tsv"</span> )</code></pre></div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#loading-raw-files">Loading raw files</a></li>
      <li><a href="#merging-everything">Merging everything</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
<!-- <img src="images/LSP_Horiz-Logo.jpg" style="float:left;height:75px;margin:0px 10px"> -->
<p>This vignette is a part of the <a href="https://github.com/datarail/workflows">"LSP analysis workflows"</a> GitHub repo.<br><b>Authors:</b> Artem Sokolov<br>
Laboratory of Systems Pharmacology<br>
Havard Medical School<br></p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>
      </footer>
</div>

  

  </body>
</html>
